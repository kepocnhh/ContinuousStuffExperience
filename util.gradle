private static def getFileText(String filePath) {
    return getFileText(new File(filePath))
}
private static def getFileText(File file) {
    if(file == null || !file.exists()) {
        throw new IllegalStateException("File by path \"${file.absolutePath}\" must exist!")
    }
    return file.getText("UTF-8")
}

private static def getTestCoverageResult(String filePath) {
    return parseXml(getFileText(filePath)).counter.inject(1.0) { accumulator, item ->
        def covered = item.@covered.toInteger()
        def sum = item.@missed.toInteger() + covered
        if(sum > 0) {
            (accumulator + covered / sum) / 2
        } else accumulator
    }
}
private static def getTestingResult(String filePath) {
    def data = getFileText(filePath)
    def index = data.indexOf("\"successRate\"")
    if(index < 0) throw new IllegalStateException("Tag \"successRate\" must exist!")
    index = data.indexOf("\"percent\"", index)
    if(index < 0) throw new IllegalStateException("Tag \"percent\" must exist!")
    def indexLeft = data.indexOf(">", index)
    if(indexLeft < 0) throw new IllegalStateException("\">\" after \"percent\" must exist!")
    def indexRight = data.indexOf("%<", indexLeft)
    if(indexRight < 0) throw new IllegalStateException("\"%<\" after \">\" must exist!")
    def result = data.substring(indexLeft + 1, indexRight)
    return result.equals("100")
}

private static def getXmls(FileCollection testResultDirs) {
    def xmls = []
    def endsWithBinary = "/binary"
    testResultDirs.each {
        if(it.absolutePath.endsWith(endsWithBinary)) {
            def dir = new File(it.absolutePath[0..-endsWithBinary.length()])
            if(dir.exists()) {
                dir.eachFile { f ->
                    if(f.name.endsWith(".xml")) {
                        xmls.add(f)
                    }
                }
            }
        }
    }
    return xmls
}
private static def getTestingSignature(FileCollection testResultDirs) {
    return getXmls(testResultDirs).inject("") { accumulator, file ->
        def root = parseXml(getFileText(file))
        root.attributes().remove("timestamp")
        root.attributes().remove("hostname")
        root.attributes().remove("time")
        root.testcase.each { testcase ->
            testcase.attributes().remove("time")
            testcase.failure.each { failure ->
                failure.value = []
            }
        }
		StringWriter stringWriter = new StringWriter()
		XmlNodePrinter nodePrinter = new XmlNodePrinter(new PrintWriter(stringWriter))
		nodePrinter.setPreserveWhitespace(true)
		nodePrinter.print(root)
        accumulator + stringWriter.toString()
    }
}

private static def parseXml(String data) {
    def xmlParser = new XmlParser()
    xmlParser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false) 
    xmlParser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    return xmlParser.parseText(data)
}

private static def getTestCoverageResultBadgeColor(double result) {
    if(result > 1 || result < 0) {
        throw new IllegalStateException("Test coverage must be in [0..1] but $result!")
    } else if(result < 0.5) {
        return "d50000"
    } else if(result < 0.75) {
        return "ffd600"
    } else {
        return "00c853"
    }
}
private static def getTestingResultBadgeColor(boolean isPassed) {
    if(isPassed) {
        return "00c853"
    } else {
        return "d50000"
    }
}

ext {
    getFileText = this.&getFileText
    getTestCoverageResult = this.&getTestCoverageResult
    getTestingResult = this.&getTestingResult
    getTestingSignature = this.&getTestingSignature
    getTestCoverageResultBadgeColor = this.&getTestCoverageResultBadgeColor
    getTestingResultBadgeColor = this.&getTestingResultBadgeColor
    createBadgeUrl = { String urlTitle, String urlValue, String color ->
        "https://img.shields.io/badge/$urlTitle-$urlValue-${color}.svg?style=flat"
    }
}