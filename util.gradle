private def getFileText(String filePath) {
    return getFileText(file(filePath))
}
private def getFileText(File file) {
    if(file == null || !file.exists()) {
        throw new IllegalStateException("File by path \"$filePath\" must exist!")
    }
    return file.getText("UTF-8")
}

private def getTestCoverageResult(String filePath) {
    return parseXml(getFileText(filePath)).counter.inject(1.0) { result, item ->
        def covered = item.@covered.toInteger()
        def sum = item.@missed.toInteger() + covered
        if(sum > 0) {
            result = (result + covered / sum) / 2
        }
    }
}
private def getTestingResult(String filePath) {
    def data = getFileText(filePath)
    def index = data.indexOf("\"successRate\"")
    if(index < 0) throw new IllegalStateException("Tag \"successRate\" must exist!")
    index = data.indexOf("\"percent\"", index)
    if(index < 0) throw new IllegalStateException("Tag \"percent\" must exist!")
    def indexLeft = data.indexOf(">", index)
    if(indexLeft < 0) throw new IllegalStateException("\">\" after \"percent\" must exist!")
    def indexRight = data.indexOf("%<", indexLeft)
    if(indexRight < 0) throw new IllegalStateException("\"%<\" after \">\" must exist!")
    def result = data.substring(indexLeft + 1, indexRight)
    return result.equals("100")
}

private def getXmls(FileCollection testResultDirs) {
    def xmls = []
    def endsWithBinary = "/binary"
    testResultDirs.each {
        if(it.absolutePath.endsWith(endsWithBinary)) {
            def dir = file(it.absolutePath[0..-endsWithBinary.length()])
            if(dir.exists()) {
                dir.eachFile { f ->
                    if(f.name.endsWith(".xml")) {
                        xmls.add(f)
                    }
                }
            }
        }
    }
    return xmls
}
private def getTestingSignature(FileCollection testResultDirs) {
    return getXmls(testResultDirs).inject("") { accumulator, file ->
        def root = parseXml(getFileText(file))
        root.attributes().remove("timestamp")
        root.attributes().remove("hostname")
        root.attributes().remove("time")
        root.testcase.each { testcase ->
            testcase.attributes().remove("time")
            testcase.failure.each { failure ->
                failure.value = []
            }
        }
		StringWriter stringWriter = new StringWriter()
		XmlNodePrinter nodePrinter = new XmlNodePrinter(new PrintWriter(stringWriter))
		nodePrinter.setPreserveWhitespace(true)
		nodePrinter.print(root)
        accumulator + stringWriter.toString()
    }
}
private def getTestingSignatureOld(String path) {
    def signatureTempPath = "$path/signatureTempPath"
    file(signatureTempPath).deleteDir()
    file(signatureTempPath).mkdirs()
    file("$signatureTempPath/classes").mkdirs()
    file("$path/html/classes").eachFile {
        def prevLine = null
        file("$signatureTempPath/classes/${it.name}") << it.readLines().collect { line ->
            def tmp = prevLine
            prevLine = line
            checkLine(tmp, line)
        }.join("")
    }
    file("$signatureTempPath/packages").mkdirs()
    file("$path/html/packages").eachFile {
        def prevLine = null
        file("$signatureTempPath/packages/${it.name}") << it.readLines().collect { line ->
            def tmp = prevLine
            prevLine = line
            checkLine(tmp, line)
        }.join("")
    }
    def files = []
    file(signatureTempPath).eachFileRecurse {
        if(!it.isDirectory())
        if(it.name.endsWith(".html")) {
            files.add(it)
        }
    }
    def result = files.sort { it.absolutePath }.inject("") { accumulator, file ->
        accumulator + getFileText(file.absolutePath)
    }
    file(signatureTempPath).deleteDir()
    return result
}
private def checkLine(String prevLine, String line) {
    if(line.contains("http-equiv") && line.contains("\"x-ua-compatible\"")) return ""
    else if(prevLine != null) {
        if(prevLine.contains("\"infoBox\"") && prevLine.contains("\"duration\"")
            || prevLine.contains("</td>") && line.contains("s</td>")
            || prevLine.contains("Generated by")) return ""
    }
    return line
}

private def parseXml(String data) {
    def xmlParser = new XmlParser()
    xmlParser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false) 
    xmlParser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    return xmlParser.parseText(data)
}

private def getTestCoverageResultBadgeColor(double result) {
    if(result > 1 || result < 0) {
        throw new IllegalStateException("Test coverage must be in [0..1] but $result!")
    } else if(result < 0.5) {
        return "d50000"
    } else if(result < 0.75) {
        return "ffd600"
    } else {
        return "00c853"
    }
}
private def getTestingResultBadgeColor(boolean isPassed) {
    if(isPassed) {
        return "00c853"
    } else {
        return "d50000"
    }
}

ext {
    getFileText = this.&getFileText
    getTestCoverageResult = this.&getTestCoverageResult
    getTestingResult = this.&getTestingResult
    getTestingSignature = this.&getTestingSignature
    getTestCoverageResultBadgeColor = this.&getTestCoverageResultBadgeColor
    getTestingResultBadgeColor = this.&getTestingResultBadgeColor
    createBadgeUrl = { String urlTitle, String urlValue, String color ->
        "https://img.shields.io/badge/$urlTitle-$urlValue-${color}.svg?style=flat"
    }
}